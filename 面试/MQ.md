##	MQ的面试总结

1. **MQ的使用场景及作用**

   **好处一：解耦**

   比如我们的货款抵扣业务场景，用户生成订单发送MQ后立即返回，结算系统去消费该MQ进行用户账			户金额的扣款。这样订单系统只需要关注把订单创建成功，最大可能的提高订单量，并且生成订单后立			即返回用户。而结算系统重点关心的是账户金额的扣减，保证账户金额最终一致。

   **好处二：冗余**

   有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。MQ把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多MQ所采用的"插入-获取-删除"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

   **好处三：扩展性**

   因为MQ解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。就比如DMS分布式消息服务，不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。

   **好处四：灵活性和峰值处理能力**

   在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用MQ能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

   比如订单系统和结算系统场景为例，如果订单系统通过RPC框架来调用结算系统，在有高峰促销的情况下生成订单的量会非常大，而且由于生成订单的速度也非常快，这样势必会给结算系统造成系统压力，服务器利用率则会偏高，但在不是高峰的时间点订单量比较小，结算系统的服务器利用率则会偏低。

   那么如果通过MQ的方式，将订单存储到MQ队列中，消费端通过拉取的方式，并且拉去速度有消费端来控制，则就可以控制流量趋于平稳。这样对于结算系统来讲，就达到了削峰填谷的目的。或者说起到了流控的目标

   **好处五：可恢复性**

   系统的一部分组件失效时，不会影响到整个系统。MQ降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

   **好处六：顺序保证**

   在大多使用场景下，数据处理的顺序都很重要。大部分MQ本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。

   **好处七：缓冲**

   在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。

   **好处八：异步通信**

   很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

   总结的使用场景：业务解耦，服务峰值变化，消息需要恢复，需要有序性，异步通信。

2. **RocketMQ的消息类型及作用**

   根据发送特点分为：

   ​	同步消息：

   ​	异步消息：

   ​	单向消息：

   根据功能特点分为：

   ​	普通消息：

   ​	顺序消息：

   ​	广播消息：

   ​	延时消息：

   ​	批量消息：

   ​	事务消息：

3. **RocketMQ的消费模式**

   1.**广播模式**

   ​	广播模式会一条消息会被多个consumer消费

   2.**集群模式**

   ​	一条消息只会被一个consumer消费，队列中的消息被consumer实例平均分摊

