##	mysql的最左原则

###	索引最左原则

也叫索引前缀原则

假设一张表`t`有 `a`、`b`、`c`、`d`四个字段，给表`t`建立`a`、`b`、`c`顺序联合索引；在查询的时候，条件必须要有`a`字段才能用到索引

**！注意：**跟字段的顺序没关系，跟缺省值有关系；因为缺字段，破坏了索引树的结构，而顺序优化器会帮我们调整过来

所以上述例子： 

1. 条件中有`a`的时候会用到`a`字段的有序性；

   ```sql
   -- 会用到a的有序性,跟条件的顺序无关
   select * from t where d = ? and a = ?;
   
   -- 只会用到a的有序性，因为c的有序性要建立在b的基础上，条件中没有b
   select * from t where a = ? and c = ? and d = ?;
   ```

2. 条件中有`a`、`b`字段的时候，会用到`a`和`b`的有序性；

   ```sql
   -- 会用到a b的有序性
   select * from t where d = ? and b = ? and a = ?;
   ```

3. 条件中有`a`、`b`、`c`字段的时候，会用到三个字段的有序性；

   ```sql
   -- 会用到a b c的有序性
   select * from t where d = ? and c = ? and b = ? and a = ?;
   ```

4. 其他情况都不会用到索引

   ```sql
   select * from t where b = ? and c = ?;
   select * from t where c = ? and d = ?;
   ```

为什么呢？是因为索引其实维持了一颗有序的树结构，上述索引的树结构顺序如下表：

| a    | b    | c    |
| ---- | ---- | ---- |
| 1    | 1    | 1    |
| 1    | 1    | 2    |
| 1    | 2    | 4    |
| 2    | 1    | 2    |
| 3    | 4    | 5    |

索引最左边的列是全有序，后面的列在前面列的基础上再次有序。